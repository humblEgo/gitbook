# 2021-03-26\(Fri\)

| 항목 | 내용 |
| :--- | :--- |
| 학습 날짜 | 2021-03-26\(금\) |
| 학습 시간 | 11:00~23:00 |
| 학습 범위 및 주제 | 스프링 시큐리티 |
| 학습 목표 | 스프링 시큐리티를 맛본다. |
| 동료 학습 방법 | - |

## 상세 학습 내용

#### 스프링 시큐리티와 OAuth 2.0으로 로그인 기능 구현하기

스프링 기반의 애플리케이션에서는 보안을 위한 표준이고, 인터셉터, 필터 기반의 보안 기능을 구현하는 것보다 더 권장하고 있다.

### 직렬화란 무엇일까?

객체의 직렬화는 객체의 내용을 바이트 단위로 변환하여 파일 또는 네트워크를 통해서 스트림\(송수신\)이 가능하도록 하는 것을 의미한다.

자바의 I/O 처리는 정수, 문자열 바이트 단위의 처리만 지원했었다. 따라서 복잡한 내용을 저장/복원 하거나, 네트워크로 전송하기 위해서는 객체의 멤버변수의 각 내용을 일정한 형식으로 만들어\(이것을 패킷이라고 한다\) 전송해야 했다.

객체 직렬화는 객체의 내용\(구체적으로는 멤버변수의 내용\)을 자바 I/O가 자동적으로 바이트 단위로 변환하여, 저장/복원하거나 네트워크로 전송할 수 있도록 기능을 제공해준다. 즉 개발자 입장에서는 객체가 아무리 복잡하더라도, 객체직렬화를 이용하면 객체의 내용을 자바 I/O가 자동으로 바이트 단위로 변환하여 저장이나 전송을 해주게 된다.

자바에서 직렬화는 자동으로 처리해주는 것이기 떄문에 운영체제가 달라도 전혀 문제되지 않는다. 객체를 직렬화할 때 객체의 멤버변수가 다른 객체\(Serializable 인터페이스를 구현한\)의 레퍼런스 변수인 경우에는 레퍼런스 변수가 가리키는 해당 객체까지도 같이 객체직렬화를 해버린다.

엔티티 클래스의 경우엔 언제 다른 엔티티와 관계\(@OneToMany나 @ManyToMany\)를 갖게 되면 직렬화 대상에 관계를 맺은 다른 객체까지 포함되어버린다.

때문에 책에서는 엔티티 클래스를 그대로 리턴하는 것이 아니라, 직렬화 기능을 가진 세션 Dto를 하나 추가로 만들어서 운영 및 유지보수를 용이하게 하도록 한 것이다.

### 객체 전송의 단계

1. 직렬화된 객체를 바이트 단위로 분해한다.\(marshalling\)
   * 마샬링\(Marshalling\)은 데이터를 바이트의 덩어리로 만들어 스트림에 보낼 수 있는 형태로 바꾸는 변환작업을 뜻한다.
   * 자바에서 마샬링을 적용할 수 있는 데이터는 원시 자료형과 객체 중에서 Serializable 인터페이스를 구현한 클래스로 만들어진 객체이다.
2. 직렬화 되어 분해된 데이터를 순서에 따라 전송한다.
3. 전송 받은 데이터를 원래대로 복구한다.\(unmarshalling\)

* [참고](https://weicomes.tistory.com/63)

  \*\*\*\*

### **세션 저장소로 데이터베이스 사용하기**

현재는 내장 톰캣의 메모리에 세션이 저장되므로, 애플리케이션을 재실행하면 로그인이 풀린다. 배포할 때마다 톰캣이 재시작되는 것이다.

때문에 현업에서는 세션 저장소에 대해 다음 3가지 중 한 가지를 선택한다.

1. **톰캣 세션을 사용한다.**
   * 일반적으로 별다른 설정을 하지 않을 때 기본적으로 선택되는 방식
   * 톰캣\(WAS\)에 세션이 저장되기 때문에 2대 이상의 WAS가 구동되는 환경에서는 톰캣들 간의 세션 공유를 위한 추가 설정이 필요하다.
2. **MySQL과 같은 데이터베이스를 세션 저장소로 사용한다.**
   * 여러 WAS 간의 공용 세션을 사용할 수 있는 가장 쉬운 방법이다.
   * 많은 설정이 필요 없지만, 결국 로그인 요청마다 DB IO가 발생해서 성능상 이슈가 야기될 수 있다.
   * 보통 로그인 요청이 많이 없는 백오피스, 사내 시스템 용도에서 사용한다.
3. **Redis, Memcached와 같은 메모리 DB를 세션 저장소로 사용한다.**
   * B2C 서비스에서 가장 많이 사용하는 방식이다.
   * 실제 서비스로 사용하기 위해서는 Embedded Redis와 같은 방식이 아닌 외부 메모리 서버가 필요하다.

책에서는 아래 이유에서 2번째 방식을 선택하게 된다.

* 설정이 간단하다.
* 사용자가 많은 서비스가 아니다.
* 비용 절감이 가능하다. 레디스 같은 메모리 DB를 사용한다면 레디스와 같은 서비스\(엘라스틱 캐시\)에 별도로 사용료를 지불해야 하기 때문이다.

## **학습 내용에 대한 개인적인 총평**

예제 코드를 따라쳤음에도 스프링 시큐리티에서 문제가 생겼다. 놀랍게도 에러 로그가 따로 찍히지도 않아서 왜 문제가 생겼는지 추측해야했는데, 이 문제를 지금 해결하기 보다, 이제 지금 가진 갈증을 바탕으로 스프링 프레임워크를 찐하게 학습해봐야겠다는 결심이 섰다.

멘토님들과의 면담이 있었는데, 필요 이상으로 자존감을 깎을 필요도, 주제넘게 오만해질 필요도 없다. 초조함을 버리고 겸허하게 시간을 받아들이고 목표를 위해 노력하자.

## **다음 학습 계획**

* 디자인패턴 학습

