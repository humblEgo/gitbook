# 2021-04-04\(Sun\)



| 항목 | 내용 |
| :--- | :--- |
| 학습 날짜 | 2021-04-04\(일\) |
| 학습 시간 | 09:00~23:00 |
| 학습 범위 및 주제 | java의 정석 훑어보기 |
| 학습 목표 | 헷갈리는 개념들을 명확히 파보자. |
| 동료 학습 방법 | - |

## 상세 학습 내용

명료하게 말로 표현하기 힘들었던 부분들을 정리해보자~!

### 오버로딩 vs 오버라이딩

### 오버로딩

* 개념: 이름은 같지만 시그니처\(파라미터 수, 타입\)가 다른 메소드를 중복으로 선언하는 것. 즉, 기존에 없는 새로운 메서드를 정의하는 것이다.
* 특징
  * 메소드 이름이 같아야함.
  * 시그니처는 달라야함. 파라미터 수가 다르거나 타입이 다르거나, 둘 다 다르거나.
  * 리턴 값은 시그니처에 해당되지 않음.
  * 접근 제어자는 자유롭게\(같거나 다르게\) 지정할 수 있다.
* 쓰는 이유
  * 가독성 증가시킴.
  * 같은 기능을 하는 메서드 관리가 쉬워짐.

### 오버라이딩

* 개념: 부모 클래스의 메소드의 동작 방법을 변경\(재정의\)하여 우선적으로 사용하는 것.
* 특징
  * 메소드 이름이 같아야함.
  * 시그니처가 같아야함. 파라미터 수, 파라미터의 타입이 같아야한다.
  * 메소드 리턴형이 같아야한다.
  * 오버라이드 하고자 하는 메소드가 상위 클래스에 존재해야 한다.
  * 상속 받은 클래스의 메소드를 오버라이딩할 때, 스태틱 메소드를 오버라이딩 하게 되면 상위 클래스의 메소드가 하이딩 처리된다. 자바에서는 이 하이딩 처리를 권장하지 않는다.
  * `private` 메서드는 오버라이딩이 불가하다. 당연한 것이, 자식 클래스에서도 접근 불가이니까.
  * 참고로 `@Override` 어노테이션을 적어주면 오버라이딩이 제대로 구현되었는지를 컴파일 타임에 검증한다.
  * 접근 제어자를 설정하는데 별도의 규칙이 존재한다.
    * 자식 클래스에서 오버라이딩하는 메소드의 접근 제어자는 부모 클래스보다 더 좁게 설정할 수 없다.
    * 예외\(Exception\)은 부모 클래스의 메소드보다 많이 선언할 수 없다.
    * static 메소드를 인스턴스의 메소드로 또는 그 반대로 바꿀 수 없다.

### Package

* 패키지는 클래스의 묶음이다.
* 서로 관련된 클래스들끼리 그룹 단위로 묶어 놓음으로써 클래스를 효율적으로 관리할 수 있다.
* 또한 서로 다른 패키지에 같은 이름의 클래스가 정의되는 것이 가능하므로, 자신만의 패키지 체계를 유지함으로써 다른 개발자가 개발한 클래스 라이브러리의 클래스와 이름이 충돌하는 것을 피할 수 있다.
* 클래스의 실제 이름은 패키지명을 포함한 것이다. ex\) `String` 은 `java.lang.String` 이 풀네임이다. java.lang 패키지에 속한 String 클래스라는 의미.
* 클래스가 물리적으로 하나의 클래스파일\(.class\)인 것과 같이 패키지는 물리적으로 하나의 디렉토리이다.
* 자잘한 제약 특징
  * 하나의 소스 파일에는 첫 번째 문장으로 단 한번의 패키지 선언만을 허용한다.
  * 모든 클래스는 반드시 하나의 패키지에 속해야 한다. 지정하지 않으면 `unnamed package` 에 속하게 된다.
  * 패키지명은 대소문자를 모두 허용하지만, 클래스명과 쉽게 구분하기 위해서 소문자로 하는 것을 원칙으로 하고 있다.

### 추상클래스 vs 인터페이스

추상클래스는 C++에서 많이 다뤘고, 객체지향 학습하며 유용함을 체감한 바있다. 그런데 java에는 따로 인터페이스를 쓰는 것 아닌가. 인터페이스가 무엇이고 추상클래스와의 차이점이 무엇인지 확인해보자.

### 인터페이스의 특징

* 인터페이스는 일종의 추상클래스이다.
* 그래서 인터페이스는 추상클래스처럼 생성자를 가질 수 없다. 구현하는 클래스를 통해서만 인스턴스화 할 수 있다.
* 인터페이스는 추상클래스보다 추상화 정도가 높아서 **추상크래스와 달리 몸통을 갖춘 일반 메서드 또는 멤버변수를 구성원으로 가질 수 없다.** **대신 오직 추상메서드와 상수만을 멤버로 가질 수 있다.**
* 인터페이스의 멤버들은 아래 제약사항을 가진다.
  * 모든 멤버변수는 `public static final` 이어야 하며, 이를 생략할 수 있다.
  * 모든 메서드는 `public abstract` 이어야 하며, 이를 생략할 수 있다. 단, JDK1.8부터 static 메서드와 디폴트 메서드는 예외이다.
* 인터페이스는 인터페이스로부터만 상속받을 수 있다. 클래스와 달리 다중상속이 가능하다.
* 인터페이스의 이름에는 주로 Fightable과 같이 '~을 할 수 있는'의 의미인 'able'로 끝나는 것들이 많은데, 그 이유는 어떠한 기능 또는 행위를 하는데 필요한 메서드를 제공한다는 의미를 강조하기 위해서이다.
* 리턴 타입이 인터페이스라는 것은 메서드가 해당 인터페이스를 구현한 클래스의 인스턴스를 반환한다는 것을 의미한다.

### 인터페이스의 장점

* 개발 시간을 단축시킬 수 있다.
  * 인터페이스를 이용해서 클래스의 선언과 구현을 분리할 수 있다. 그럼 인터페이스 내부 구현이 완료되지 않더라도 인터페이스 선언부를 참고하여 개발이 가능하다.
* 표준화가 가능하다.
* 서로 관계없는 클래스들에게 관계를 맺어줄 수 있다. 공통점을 부여하는 것!
  * 서로 상속관계에 있지도 않고, 같은 조상클래스를 가지고 있지 않은 서로 아무런 관계도 없는 클래스들에게 하나의 인터페이스를 공통적으로 구현하도록 함으로써 관계를 맺어 줄 수 있다.
* 의존성 줄이는 설계가 가능하다.

### 그래서 추상클래스와 인터페이스의 공통점/차이점은?

### **공통점**

1. 둘 다 선언만 있고 구현 내용이 없다.
2. 그래서 인스턴스화를 할 수 없다.
3. 결국 자식 클래스가 무언가를 반드시 구현하도록 위임해야할 때 사용한다.

### **차이점**

1. 목적
   * 추상 클래스: **공통적인 기능을 하는 객체들의 추상화**
   * 인터페이스: **구현하는 모든 객체에 대해 특정한 메서드가 반드시 존재하도록 보장하기 위함.**
   * 상속 가능 수
     * 추상 클래스: 단일 상속만 가능
     * 인터페이스: 다중 상속 가능
   * 사용하는 상황
     * 추상 클래스: 말 그대로 추상화 시킬 때 사용하면 된다. 공통점을 찾아서 추상화시켜서 사용하는 것이 개발에서 이득일 때 사용하자.
     * 인터페이스: 특정 데이터타입의 행위를 특별하게 구현하기를 원하지만 누가 그것의 행위를 구현 했는지에 대해 관심이 없을 때. 그리고 다중 구현상속의 이점을 누려야할 때 사용하자.

[참고](https://jeong-pro.tistory.com/82)

### 디폴트 메서드

인터페이스가 변경되지 않으면 좋겠지만, 아무리 설계를 잘해도 변경할 일이 생기기 마련이다. 그럼 인터페이스가 추상메서드로만 이뤄져있다면, 인터페이스를 구현한 모든 클래스들이 새로 추가된 메서드를 구현해야한다는 문제가 있다. 이에 JDK 설계자들은 고심 끝에 디폴트 메서드\(default method\)를 고안해냈다.

디폴트 메서드는 조상 클래스에 새로운 메서드를 추가한 것과 동일한 효과를 누릴 수 있다.

## 학습 내용에 대한 개인적인 총평

개발 진짜 잘하고 싶다.. 이게 참 잘하면 만들고 싶은거 뚝딱뚝딱 만들 수 있을 것 같은데!!

## 다음 학습 계획

* QR 코드 리더기에 테이블 붙이기

