# 2021-05-25\(Tue\)

## Facts \(사실, 객관\)

코드숨 4주차 강의를 수강하였다.

## Feelings \(느낌, 주관\)

이전에 윤석 트레이너님 덕에 repository 객체로 관심을 분리하는 수준으로 코드를 발전 시켰는데, 아샬님이 강의에서 같은 흐름으로 구현하시는걸 보고 괜히 뿌듯했다.

한편 내가 아직 상속과 구현에 대한 개념이 부족한 것을 느꼈다. `CrudRepository`와 `TaskRepository`를 모두 상속한 `JpaTaskRepository`를 `InMemoryTaskRepository`에 구현하는 부분에서 혼란이 찾아왔다.

두 인터페이스를 상속한 인터페이스를 구현하는 것이니, 두 인터페이스에 속한 모든 메소드를 구현해야할 것 같은데, 강의에서는 일부만 구현한 것처럼 보였기 때문이다. 흠 아마 내가 착각한 것 같은데, 내일 복습해봐야겠다.

JPA가 능숙하지 않은데, 이번 주에 많이 배워야겠다.

## Findings \(배운 점\)

### 오버라이딩에 대한 오해

아샬님이 Iterable을 리턴하는 메소드를 List를 리턴하는 메소드로 오버라이딩하는 것을 보며 내가 오버라이딩을 제대로 모르는 것을 느껴서 다시 훑어보았다.

결과적으로 오버라이딩에 대해서 오해하고 있었다.

내가 알고 있던오버라이딩의 조건은 다음과 같았다.

> 자손 클래스에서 오버라이딩하는 메서드는 조상 클래스의 메서드와
>
> * 이름이 같아야 한다.
> * 매개변수가 같아야 한다.
> * 반환타입이 같아야 한다.

그런데 JDK1.5부터는 '공변 반환타입\(covariant return type\)'이 추가되어, **반환타입을 자손 클래스의 타입으로 변경하는 것이 가능하도록 조건이 완화** 되었다는 것을 알게 되었다.

### 클린 아키텍처

![image](https://user-images.githubusercontent.com/54612343/119511984-e42bce00-bdad-11eb-9356-b252250d052b.png)

위 클린 아키텍처에서는 관심사에 따라 layer를 나누었다. 의존성의 방향을 관리해야 하는데, 의존성이 바깥 원에서 안으로 향하도록 구현해야 한다. 도메인 layer는 위 그림의 엔티티에 해당한다.

의존 방향을 알아내기 위해 코드를 고치고 오류를 확인하는 테크닉을 배웠다.

[참고](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)

### JPA

Jav의 ORM 기술 표준으로, 인터페이스의 모음이다. Spring data 프로젝트 중 JPA를 활용한 프로젝트인 Spring data JPA를 학습했다. JPA의 엔티티는 DB의 엔티티와 유사하다. 보통 테이블 하나가 객체 하나와 대응되는 형태다.

[참고](https://spring.io/projects/spring-data-jpa)

### 테스트는?

`@DataJpaTest` 로 실제 JPA에 연결시키거나, 목킹하면 된다.

한편 책임을 분리했기 때문에, save가 성공했을 때 task의 개수가 달라지는 것은 `TaskService`가 아니라 `Respository` 클래스의 테스트에서 검증하는 것이 바람직한 것 같다.

한편 resources 디렉토리 안에 `application.yml` 파일을 만들어서 DB 연결을 명시할 수 있다.

## Affimation \(자기 선언\)

* 나는 하루하루 성장하는 개발자다.

