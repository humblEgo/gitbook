---
description: Lock은 동시성 제어 기법이다.
---

# Lock\(잠금\)이란?

## Lock의 정의

> **동시에 접근**하여 **수정**하려고 할 때 데이터베이스의 **일관성**이 깨질 수 있다. 이걸 막기 위해 트랜잭션과 lock이 쓰인다.

트랜잭션이 사용하는 자원에 대해서 상호 배제\(Mutual Exclusive\) 기능을 제공하는, 동시성 제어 기법이 lock이다.상호 배제란 특정 트랜잭션이 데이터 항목에 대하여 잠금\(Lock\)을 설정한 트랜잭션이 해제\(unlock\) 할 때까지 데이터를 독점적으로 사용할 수 있는 것을 뜻한다.

## Lock의 종류

#### 공유 Lock\(Shared Lock\)

* Read Lock이라고도 한다.
* 공유 잠금한 트랜잭션이 데이터 항목에 대하여 읽기\(read\)만 가능
* 다른 트랜잭션도 읽기\(Read\) 만을 실행 할 수 있는 형태

#### 전용 Lock\(Exclusive Lock\)

* Write Lock이라고도 한다.
* 전용 잠금한 트랜잭션은 데이터 항목에 대해서 읽기\(read\)와 기록\(write\)가 모두 가능
* 다른 트랜잭션은 읽기\(read\)와 기록\(write\) 모두 할 수 없다.

그래서 **읽기 잠금은 쓰기 잠금과 충돌**을 일으키며, **쓰기 잠금은 읽기 잠금 및 쓰기 잠금과 충돌**을 일으킨다.

## Lock의 단위

Locking 단위가 큰 순서에서 작은 순서로 나타내면 아래와 같다.

1. 데이터베이스
   * DB 전체에 영향이 있는 DB 업데이트와 같은 작업에서만 사용한다.
2. 릴레이션\(파일\)
   * 데이터베이스에서 파일이란, 테이블 등과 같이 실제 데이터가 쓰여지는 물리적인 저장소를 뜻한다. 파일 전체를 백업할 때 사용한다.
3. 테이블
   * 전체 테이블에 대해 데이터 변경이 있을 경우 사용한다.
   * DDL 구문을 사용할 때 Lock이 걸린다고하여 DDL Lock이라고도 한다.
4. 페이지와 블럭
   * 파일을 구성하는 페이지와 블록을 기준으로 Lock이 걸린다.
5. 컬럼\(Column\)
   * Lock 설정 및 해제 시 리소스가 많이 들어서 잘 사용하지 않는다.
6. 행\(Row\)
   * 가장 많이 사용되는 Lock이다.

Locking 단위가 클 수록

* 구현이 용이하다.
* 동시성이 약하다.
* Locking 오버헤드가 감소한다.

## 2단계 locking\(2PL, 2 Phase Locking\)

![&#xD558;&#xB098;&#xC758; &#xD2B8;&#xB79C;&#xC7AD;&#xC158; &#xB0B4;&#xC5D0;&#xC11C; &#xD655;&#xC7A5;&#xB2E8;&#xACC4;&#xB97C; &#xAC70;&#xCE58;&#xACE0;, &#xC218;&#xCD95;&#xB2E8;&#xACC4;&#xB97C; &#xAC70;&#xCE58;&#xBA74;&#xC11C; lock &amp; unlock &#xC218;&#xD589; \[&#xCD9C;&#xCC98;: &#xC9C0;&#xC2DD;&#xB364;&#xD504;\]](../../.gitbook/assets/image%20%284%29.png)

모든 트랜잭션을 확장 단계와 수축 단계로 나누어서 수행한다.

* 확장 단계: 트랜잭션은 lock만 수행할 수 있고, unlock은 수행할 수 없는 단계
* 수축 단계: 트랜잭션은 unlock만 수행할 수 있고, lock은 수행할 수 없는 단계

직렬 가능성을 보장할 수 있는 규약으로 많이 사용된다.

문제는 교착 상태가 발생할 가능성이 있다는 것이다. 이를 교착 상태 예방과 교착 상태 탐지로 해결한다.



### Optimistic Lock

1. 낙관적인

   기본적으로 데이터 갱신시 충돌이 발생하지 않을 것이라고 낙관적으로 보는 것.

2. 비선점적인 트랜잭션을 커밋하는 시점의 버전을 통해서 데이터를 관리한다. DB단에서 락을 하는 것이 아니라, 어플리케이션 레이어에서 거는 락이다. 충돌이 나는 경우에 이를 방지하는 정도이다.

* 장점
  * Pessimistic Lock에 비해 성능상의 이점이 있다.
  * 데드락 가능성이 적다.
* 단점
  * 충돌시 오버헤드가 생긴다. 커밋하는 시점에 충돌여부를 감지하므로, 커밋 전체를 롤백하며 오버헤드가 생기는 것.

### Pessimistic Lock

1. 비관적인

   기본적으로 데이터 갱신시 충돌이 발생할 것이라고 비관적으로 보고 미리 잠금을 건다.

2. 선점적인

   데이터 갱신시 충돌이 발생할 것이라고 예상하기 때문에, 우선적으로 락을 건다. 즉, 조회할 때 부터 건다.

* 장점
  * 무결성을 지키기 용이하다
  * 충돌에 대한 오버헤드가 줄어든다.
* 단점
  * 충돌이 없으면 오버헤드가 발생한다.
  * 데드락의 위험성이 있다.

다양한 추가 설정

* Shared Lock
  * Read lock이라고도 한다.
  * 다른 사용자가 동시에 읽을 수는 있지만, Update와 Delete는 방지한다.
* Exclusive Lock
  * Write lock이라고도 한다.
  * 다른 사용자가 읽기, 수정, 삭제 모두를 불가능하게 한다.

#### 그래서 어떤 상황에 무엇을 택해야하는가?

락은 비싸므로, 아래 상황을 고려해서 선택하자.

* 충돌이 자주 발생하는 상황인가?
  * 자주 발생한다면 Pessimistic Lock이 좀 더 적절할 것이다.
* 읽기와 수정하기의 비율은 어디에 가까운가?
  * 읽기가 더 많다면 Optimistic Lock이 좀 더 적절할 것이다.
  * 그래서 일반적으로 웹 어플리케이션은 Optimistic Lock을 주로 사용한다.

PessimisticLock Scope로 연관관계 설정도 할 수 있다.



